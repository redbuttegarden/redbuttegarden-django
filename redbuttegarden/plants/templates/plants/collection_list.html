{% extends 'base.html' %}
{% load static %}
{% load render_table from django_tables2 %}

{% block title %}
  Living Collections
{% endblock %}

{% block extra_css %}
  <script src="https://unpkg.com/htmx.org@2.0.4"></script>
  <link href="{% static 'plants/css/collection_list.css' %}" rel="stylesheet" />
{% endblock %}

{% block content %}
  {% if additional_html %}
    {% autoescape off %}
      {{ additional_html }}
    {% endautoescape %}
  {% endif %}

  {# Filters form: method GET so URL contains filters; hx-get makes it an HTMX request #}
  {# inside plants/templates/plants/collection_list.html #}
  <form id="collection-filter-form" method="get" class="row g-2 align-items-end mb-3" hx-get="{{ request.path }}" hx-target="#table-container" hx-swap="outerHTML" hx-push-url="true" hx-trigger="keyup changed delay:500ms, submit">
    {% for field in filter.form %}
      <div class="col-sm-6 col-md-4">
        <label for="{{ field.id_for_label }}" class="form-label small text-muted">{{ field.label }}</label>
        {{ field }}
        {% if field.help_text %}
          <div class="form-text">{{ field.help_text }}</div>
        {% endif %}
      </div>
    {% endfor %}

    <div class="col-auto">
      <button type="submit" class="btn btn-primary">Filter</button>
      <a href="{{ request.path }}" class="btn btn-outline-secondary">Clear</a>
    </div>
  </form>

  {# Table container â€” htmx will replace this container with the fragment #}
  <div id="table-container">
    {# initial server-rendered table (non-HTMX) - reuse same fragment for consistency #}
    {% include 'plants/collection_list_table.html' %}
  </div>
{% endblock %}

{% block extra_js %}
  <script src="{% static 'plants/js/name_styling.js' %}"></script>
  <script src="{% static 'plants/js/style_rows.js' %}"></script>

  {# Small DOM helper: add bootstrap form-control classes to filter inputs/selects/textarea if they don't have them. #}
  <script>
    ;(function () {
      function addFormControl() {
        const container = document.getElementById('collection-filter-form')
        if (!container) return
        const controls = container.querySelectorAll('input[type="text"], input[type="search"], select, textarea')
        controls.forEach(function (el) {
          if (!el.classList.contains('form-control')) {
            el.classList.add('form-control')
          }
        })
        // style checkboxes/radios if present
        const bools = container.querySelectorAll('input[type="checkbox"], input[type="radio"]')
        bools.forEach(function (el) {
          if (!el.classList.contains('form-check-input')) {
            el.classList.add('form-check-input')
            // wrap with label if needed could be more work
          }
        })
        // style the submit/clear buttons (if not already)
        const buttons = container.querySelectorAll('button[type="submit"], a.btn')
        buttons.forEach(function (b) {
          if (!b.classList.contains('btn')) {
            b.classList.add('btn', 'btn-primary')
          }
        })
      }
    
      // run on load and also when htmx swaps content (to ensure new inputs are styled)
      document.addEventListener('DOMContentLoaded', addFormControl)
      document.body.addEventListener('htmx:afterSwap', function (evt) {
        // if swap replaced the filter form or table, re-apply styles
        addFormControl()
      })
    })()
  </script>
  <script>
    ;(function () {
      // Ensure this runs after htmx is loaded. If htmx isn't defined, we'll log an error.
      function debug(...args) {
        if (window && window.console) console.log('[PLANTS HTMX]', ...args)
      }
    
      // Keep a pending href that we want to push to history after the swap completes.
      window._rbg_pending_htmx_push = null
    
      // Delegated click handler for links inside #table-container
      document.body.addEventListener('click', function (e) {
        const a = e.target.closest('#table-container a')
        if (!a) return
    
        const href = a.getAttribute('href') || ''
        if (!href) return
    
        // Do not intercept export links or explicit new-tab links
        if (href.includes('_export=') || a.target === '_blank') {
          debug('Not intercepting export/new-tab link:', href)
          return
        }
    
        // Prevent standard navigation
        e.preventDefault()
    
        // Make sure htmx is available
        if (typeof window.htmx === 'undefined') {
          debug('htmx is not defined; falling back to normal navigation for', href)
          // fallback to normal navigation if htmx isn't available
          window.location.href = href
          return
        }
    
        debug('Intercepted pagination/link click:', href)
    
        // Mark for history push after the swap completes
        window._rbg_pending_htmx_push = href
    
        // Use htmx to fetch and swap the container; ask htmx to try to push URL too.
        // We still implement a fallback via history.pushState in the afterSwap listener below.
        try {
          htmx.ajax('GET', href, {
            target: '#table-container',
            swap: 'outerHTML',
            pushUrl: true
          })
        } catch (err) {
          // If htmx.ajax threw for some reason, fall back to a fetch + swap (rare)
          debug('htmx.ajax threw an error, falling back. Error:', err)
          fetch(href, { credentials: 'same-origin' })
            .then((resp) => resp.text())
            .then((html) => {
              // attempt to extract the #table-container from the response html
              const parser = new DOMParser()
              const doc = parser.parseFromString(html, 'text/html')
              const newContainer = doc.querySelector('#table-container')
              if (newContainer) {
                const old = document.querySelector('#table-container')
                old.replaceWith(newContainer)
                debug('Fallback: swapped #table-container manually for', href)
                // push URL manually
                history.pushState({}, '', href)
                window._rbg_pending_htmx_push = null
              } else {
                debug('Fallback: could not find #table-container in response; navigating normally.')
                window.location.href = href
              }
            })
            .catch((fetchErr) => {
              debug('Fallback fetch error:', fetchErr)
              window.location.href = href
            })
        }
      })
    
      // After HTMX swaps content, push pending URL if any.
      document.body.addEventListener('htmx:afterSwap', function (evt) {
        // Only act when a pending href was set by our click handler
        const pending = window._rbg_pending_htmx_push
        if (!pending) return
    
        // Safety: if the swap replaced #table-container, then push the new URL
        // also check that target id was table-container (evt.detail.elt may be the swapped element)
        try {
          // pushState is safe and won't reload the page
          history.pushState({}, '', pending)
          debug('Pushed URL to history after HTMX swap:', pending)
        } catch (err) {
          debug('history.pushState failed:', err)
        } finally {
          window._rbg_pending_htmx_push = null
        }
      })
    
      // Optional: log when HTMX requests start/end for debugging
      document.body.addEventListener('htmx:beforeRequest', function (evt) {
        debug('htmx:beforeRequest', evt.detail.path || evt.detail.requestConfig || evt)
      })
      document.body.addEventListener('htmx:afterRequest', function (evt) {
        debug('htmx:afterRequest', evt.detail.path || evt.detail.requestConfig || evt)
      })
    })()
  </script>
{% endblock %}
